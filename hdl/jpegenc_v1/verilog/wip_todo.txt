BUF_FIFO.v-89-
BUF_FIFO.v:90:    /// @todo: better home, these were in a global package in
BUF_FIFO.v-91-    ///    the VHDL version.  Might need to use a header file,
BUF_FIFO.v-92-    ///    don't believe the 
BUF_FIFO.v-93-    parameter C_EXTRA_LINES = 8;
BUF_FIFO.v-94-    parameter C_MAX_LINE_WIDTH = 1280;
BUF_FIFO.v-95-    
--
ByteStuffer.v-72-#(
ByteStuffer.v:73:  /// @todo: these were constants from JPEG_PKG, not sure if
ByteStuffer.v-74-  ///    this should be repeated in each module or in a header
ByteStuffer.v-75-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
ByteStuffer.v-76-  parameter C_HDR_SIZE = 623
ByteStuffer.v-77-)  
ByteStuffer.v-78-(
--
CtrlSM.v-149-    
CtrlSM.v:150:    // @todo: check, VHDL used global values from the package
CtrlSM.v-151-    //    need to verify these are correct
CtrlSM.v-152-    localparam NUM_STAGES = 6;
CtrlSM.v-153-    localparam CMP_MAX = 4;
CtrlSM.v-154-	
CtrlSM.v:155:    /// @todo: verify correct encoding for states
CtrlSM.v-156-    localparam
CtrlSM.v-157-      IDLES = 1,
CtrlSM.v-158-      JFIF  = 2,
CtrlSM.v-159-      HORIZ = 3,
CtrlSM.v-160-      COMP  = 4,
--
DCT1D.v-78-#(
DCT1D.v:79:  /// @todo: these were constnats from MDCT_PKG, not sure if
DCT1D.v-80-  ///    this should be repeated in each module or in a header
DCT1D.v-81-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
DCT1D.v-82-  parameter IP_W        = 8,  
DCT1D.v-83-  parameter OP_W        = 12,
DCT1D.v-84-  parameter N           = 8,
--
DCT1D.v-105-
DCT1D.v:106:    // @todo: fix, manually convert
DCT1D.v-107-    //romedatao    : in T_ROM1DATAO;
DCT1D.v-108-    //romodatao    : in T_ROM1DATAO;
DCT1D.v-109-    
DCT1D.v:110:    // @todo: fix, manually convert
DCT1D.v-111-    //romeaddro    : out T_ROM1ADDRO;
DCT1D.v-112-    //romoaddro    : out T_ROM1ADDRO;
DCT1D.v-113-
DCT1D.v-114-
DCT1D.v-115-
DCT1D.v:116:    // @todo: manually convert
DCT1D.v-117-    reg [IP_W:0] databuf_reg[N - 1:0];
DCT1D.v-118-    reg [IP_W:0] latchbuf_reg[N - 1:0];
DCT1D.v-119-    
DCT1D.v-120-    reg  [(RAMADRR_W/2) - 1:0] col_reg = 0;
DCT1D.v-121-    reg  [(RAMADRR_W/2) - 1:0] row_reg = 0;
--
DCT1D.v-152-
DCT1D.v:153:    // @todo: fix, manually convert
DCT1D.v-154-    //signal romedatao_d1    : T_ROM1DATAO;
DCT1D.v-155-    //signal romodatao_d1    : T_ROM1DATAO;
DCT1D.v-156-    //signal romedatao_d2    : T_ROM1DATAO;
DCT1D.v-157-    //signal romodatao_d2    : T_ROM1DATAO;
DCT1D.v-158-    //signal romedatao_d3    : T_ROM1DATAO;
--
DCT1D.v-202-
DCT1D.v:203:		/// @todo: manual conversion / fix.  latchbuf is a 2D array
DCT1D.v-204-		///    need to verify latchbuf_reg is supposed to be a 2D
DCT1D.v-205-		///    and what the following is trying to actually achive
DCT1D.v-206-		// right shift input data
DCT1D.v-207-		//latchbuf_reg[N - 2:0] <= latchbuf_reg[N - 1:1];
DCT1D.v-208-		
--
DCT1D.v-267-	    
DCT1D.v:268:	    /// @todo: manually fix, concat expression fails
DCT1D.v-269-	    //ramwaddro_d1 <= {(((RAMADRR_W - 1))-((0))+1){1'b0}};
DCT1D.v-270-	    //ramwaddro_d2 <= {(((RAMADRR_W - 1))-((0))+1){1'b0}};
DCT1D.v-271-	    //ramwaddro_d3 <= {(((RAMADRR_W - 1))-((0))+1){1'b0}};
DCT1D.v-272-	    //ramwaddro_d4 <= {(((RAMADRR_W - 1))-((0))+1){1'b0}};
DCT1D.v-273-     
--
DCT1D.v-301-	    
DCT1D.v:302:	    // @todo: fix, manually convert
DCT1D.v-303-	    //if even_not_odd = '0' then
DCT1D.v:304:	    //  -- @todo: fix, manually convert
DCT1D.v-305-	    //  dcto_1 <= STD_LOGIC_VECTOR(RESIZE
DCT1D.v-306-	    //    (RESIZE(SIGNED(romedatao(0)),DA_W) + 
DCT1D.v-307-	    //    (RESIZE(SIGNED(romedatao(1)),DA_W-1) & '0') +
DCT1D.v-308-	    //    (RESIZE(SIGNED(romedatao(2)),DA_W-2) & "00"),
DCT1D.v-309-	    //    DA_W));
--
DCT1D.v-361-
DCT1D.v:362:    // @todo: fix, manually convert
DCT1D.v-363-    // read precomputed MAC results from LUT
DCT1D.v-364-    //p_romaddr : process(CLK, RST)
DCT1D.v-365-    //begin
DCT1D.v-366-    //  if RST = '1' then
DCT1D.v-367-    //    romeaddro   <= (others => (others => '0')); 
--
DCT2D.v-75-#(
DCT2D.v:76:  /// @todo: these were constnats from MDCT_PKG, not sure if
DCT2D.v-77-  ///    this should be repeated in each module or in a header
DCT2D.v-78-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
DCT2D.v-79-  parameter IP_W        = 8,  
DCT2D.v-80-  parameter OP_W        = 12,
DCT2D.v-81-  parameter N           = 8,
--
DCT2D.v-104-
DCT2D.v:105:// @todo: manually convert
DCT2D.v-106-//romedatao    : in T_ROM2DATAO;
DCT2D.v-107-//romodatao    : in T_ROM2DATAO;
DCT2D.v:108:// @todo: manually convert
DCT2D.v-109-//romeaddro    : out T_ROM2ADDRO;
DCT2D.v-110-//romoaddro    : out T_ROM2ADDRO;
DCT2D.v-111-
DCT2D.v-112-
DCT2D.v-113-
--
DCT2D.v-142-reg [DA2_W - 1:0] dcto_4 = 0;
DCT2D.v:143:reg [DA2_W - 1:0] dcto_5 = 0;  // @todo: fix, manually convert
DCT2D.v-144-//signal romedatao_d1    : T_ROM2DATAO;
DCT2D.v-145-//signal romodatao_d1    : T_ROM2DATAO;
DCT2D.v-146-//signal romedatao_d2    : T_ROM2DATAO;
DCT2D.v-147-//signal romodatao_d2    : T_ROM2DATAO;
DCT2D.v-148-//signal romedatao_d3    : T_ROM2DATAO;
--
DCT2D.v-152-
DCT2D.v:153:  // @todo: fix, manually convert
DCT2D.v-154-  //ramraddro_sg:
DCT2D.v-155-  //ramraddro  <= STD_LOGIC_VECTOR(rowr_reg & colr_reg);  
DCT2D.v-156-  //rmemsel_sg:
DCT2D.v-157-  //rmemsel    <= rmemsel_reg;
DCT2D.v-158-  always @(posedge clk or posedge rst) begin
--
DCT2D.v-167-      row_reg <= {(((RAMADRR_W / 2 - 1))-((0))+1){1'b0}};
DCT2D.v:168:      // @todo: fix, manually convert
DCT2D.v-169-      //latchbuf_reg         <= (others => (others => '0')); 
DCT2D.v-170-      //databuf_reg          <= (others => (others => '0'));
DCT2D.v-171-      odv_d0 <= 1'b 0;
DCT2D.v-172-      colr_reg <= {(((RAMADRR_W / 2 - 1))-((0))+1){1'b0}};
DCT2D.v-173-      rowr_reg <= {(((RAMADRR_W / 2 - 1))-((0))+1){1'b0}};
--
DCT2D.v-183-      if(stage1_reg == 1'b 1) begin
DCT2D.v:184:        // @todo: fix, manually convert
DCT2D.v-185-        // -- right shift input data
DCT2D.v-186-        // latchbuf_reg(N-2 downto 0) <= latchbuf_reg(N-1 downto 1);
DCT2D.v-187-        // latchbuf_reg(N-1)          <= RESIZE(SIGNED(ramdatao),RAMDATA_W+1);       
DCT2D.v-188-        colram_reg <= colram_reg + 1;
DCT2D.v-189-        colr_reg <= colr_reg + 1;
--
DCT2D.v-200-          end
DCT2D.v:201:          // @todo: fix, manually convert
DCT2D.v-202-          //-- after this sum databuf_reg is in range of -256 to 254 (min to max) 
DCT2D.v-203-          //databuf_reg(0)  <= latchbuf_reg(1)+RESIZE(SIGNED(ramdatao),RAMDATA_W+1);
DCT2D.v-204-          //databuf_reg(1)  <= latchbuf_reg(2)+latchbuf_reg(7);
DCT2D.v-205-          //databuf_reg(2)  <= latchbuf_reg(3)+latchbuf_reg(6);
DCT2D.v-206-          //databuf_reg(3)  <= latchbuf_reg(4)+latchbuf_reg(5);
--
DCT2D.v-230-        stage2_cnt_reg <= {(((RAMADRR_W - 1))-((0))+1){1'b0}};
DCT2D.v:231:        // @todo: fix, manually convert
DCT2D.v-232-        //col_reg        <= (0=>'1',others => '0');
DCT2D.v-233-      end
DCT2D.v-234-      //------------------------------
DCT2D.v-235-      //--------------------------------
DCT2D.v-236-      // wait for new data
--
DCT2D.v-242-        colram_reg <= {(((RAMADRR_W / 2 - 1))-((0))+1){1'b0}};
DCT2D.v:243:        // @todo: fix, manually convert
DCT2D.v-244-        //colr_reg      <= (0=>'1',others => '0');
DCT2D.v-245-        datareadyack <= 1'b 1;
DCT2D.v-246-      end
DCT2D.v-247-      //--------------------------------
DCT2D.v-248-    end
--
DCT2D.v-278-      odv_d5 <= odv_d4;
DCT2D.v:279:      // @todo: fix, manually convert
DCT2D.v-280-      //if even_not_odd = '0' then
DCT2D.v-281-      //  dcto_1 <= STD_LOGIC_VECTOR(RESIZE
DCT2D.v-282-      //    (RESIZE(SIGNED(romedatao(0)),DA2_W) + 
DCT2D.v-283-      //    (RESIZE(SIGNED(romedatao(1)),DA2_W-1) & '0') +
DCT2D.v-284-      //    (RESIZE(SIGNED(romedatao(2)),DA2_W-2) & "00"),
--
DCT2D.v-354-  assign odv = odv_d5;
DCT2D.v:355:    // @todo: fix, manually convert
DCT2D.v-356-  //p_romaddr : process(CLK, RST)
DCT2D.v-357-  //begin
DCT2D.v-358-  //  if RST = '1' then
DCT2D.v-359-  //    romeaddro   <= (others => (others => '0')); 
DCT2D.v-360-  //    romoaddro   <= (others => (others => '0')); 
--
DoubleFifo.v-127-  //-----------------------------------------------------------------
DoubleFifo.v:128:  // @todo: manually instantiate
DoubleFifo.v-129-  //U_FIFO_1 : entity work.FIFO   
DoubleFifo.v-130-  //generic map
DoubleFifo.v-131-  //(
DoubleFifo.v-132-  //      DATA_WIDTH        => 8,
DoubleFifo.v-133-  //      ADDR_WIDTH        => 7
--
DoubleFifo.v-150-  //-----------------------------------------------------------------
DoubleFifo.v:151:  // @todo: manually instantiate
DoubleFifo.v-152-  //U_FIFO_2 : entity work.FIFO   
DoubleFifo.v-153-  //generic map
DoubleFifo.v-154-  //(
DoubleFifo.v-155-  //      DATA_WIDTH        => 8,
DoubleFifo.v-156-  //      ADDR_WIDTH        => 7
--
FDCT.v-89-    // CTRL
FDCT.v:90:    // @todo: fix, manaully fix record usage
FDCT.v-91-    //fdct_sm_settings   : in  T_SM_SETTINGS;
FDCT.v-92-    // BUF_FIFO
FDCT.v-93-    // ZIG ZAG
FDCT.v-94-    // HOST
FDCT.v-95-    
--
FDCT.v-97-    
FDCT.v:98:    // @todo: fix, manually convert ??
FDCT.v-99-    //constant C_Y_1       : signed(14 downto 0) := to_signed(4899,  15);
FDCT.v-100-    //constant C_Y_2       : signed(14 downto 0) := to_signed(9617,  15);
FDCT.v-101-    //constant C_Y_3       : signed(14 downto 0) := to_signed(1868,  15);
FDCT.v-102-    //constant C_Cb_1      : signed(14 downto 0) := to_signed(-2764, 15);
FDCT.v-103-    //constant C_Cb_2      : signed(14 downto 0) := to_signed(-5428, 15);
--
FDCT.v-216-  //-----------------------------------------------------------------
FDCT.v:217:  // @todo: fix, manually convert (instantiate)
FDCT.v-218-  //U_FRAM1 : entity work.RAMZ
FDCT.v-219-  //generic map
FDCT.v-220-  //( 
FDCT.v-221-  //    RAMADDR_W     => 7,
FDCT.v-222-  //    RAMDATA_W     => 24
--
FDCT.v-421-			  else begin
FDCT.v:422:			      /// @todo verify this is correct
FDCT.v-423-			      fram1_raddr <= {1'b0, fram1_line_cnt_p1, 3'b000};
FDCT.v-424-			  end
FDCT.v-425-		      end
FDCT.v-426-		      else begin
FDCT.v-427-			  fram1_raddr <= (((fram1_raddr)) + 2);
--
FDCT.v-439-  //-----------------------------------------------------------------
FDCT.v:440:  // @todo: fix, manually convert (instantiate)
FDCT.v-441-  //U_MDCT : entity work.MDCT
FDCT.v-442-  //      port map
FDCT.v-443-  //(	  
FDCT.v-444-  //      	clk          => CLK,
FDCT.v-445-  //      	rst          => RST,
--
FDCT.v-482-  //-----------------------------------------------------------------
FDCT.v:483:  // @todo: fix, manually convert (instantiate)
FDCT.v-484-  //U_FIFO1 : entity work.FIFO   
FDCT.v-485-  //generic map
FDCT.v-486-  //(
FDCT.v-487-  //      DATA_WIDTH        => 12,
FDCT.v-488-  //      ADDR_WIDTH        => 9
--
FDCT.v-603-      Y_Reg <= Y_Reg_1 + Y_Reg_2 + Y_Reg_3;
FDCT.v:604:      // @todo: fix, manually convert
FDCT.v-605-      //Cb_Reg <= Cb_Reg_1 + Cb_Reg_2 + Cb_Reg_3 + to_signed(128*16384, Cb_Reg'length);
FDCT.v-606-      //Cr_Reg <= Cr_Reg_1 + Cr_Reg_2 + Cr_Reg_3 + to_signed(128*16384, Cr_Reg'length);
FDCT.v-607-    end
FDCT.v-608-  end
FDCT.v-609-
--
FDCT.v-615-  //-----------------------------------------------------------------
FDCT.v:616:  // @todo: fix, manually convert (instantiate)  
FDCT.v-617-  //U_RAMZ : entity work.RAMZ
FDCT.v-618-  //generic map
FDCT.v-619-  //( 
FDCT.v-620-  //    RAMADDR_W     => 7,
FDCT.v-621-  //    RAMDATA_W     => 12
--
FIFO.v-147-    else begin
FIFO.v:148:      // @todo: manual convert the following 
FIFO.v-149-      //if count_reg = 2**ADDR_WIDTH or
FIFO.v-150-      //  (count_reg = 2**ADDR_WIDTH-1 and wr_en_reg = '1' and rd_en_reg = '0') then 
FIFO.v-151-      //  full_reg        <= '1';
FIFO.v-152-      //else
FIFO.v-153-      //  full_reg        <= '0';
--
HostIF.v-105-
HostIF.v:106:    // @todo: verify these constants, some converted funky?
HostIF.v-107-    parameter C_ENC_START_REG        = 36'h 0000_0000;
HostIF.v-108-    parameter C_IMAGE_SIZE_REG       = 36'h 0000_0004;
HostIF.v-109-    parameter C_IMAGE_RAM_ACCESS_REG = 36'h 0000_0008;
HostIF.v-110-    parameter C_ENC_STS_REG          = 36'h 0000_000C;
HostIF.v-111-    parameter C_COD_DATA_ADDR_REG    = 36'h 0000_0010;
--
HostIF.v-247-          endcase
HostIF.v:248:          // @todo: fix, manually convert
HostIF.v-249-          //if std_match(OPB_ABus, C_QUANTIZER_RAM_LUM) then
HostIF.v-250-          //  qdata      <= OPB_DBus_in(qdata'range);
HostIF.v-251-          //  qaddr      <= '0' & OPB_ABus(qaddr'high+2-1 downto 2);
HostIF.v-252-          //  qwren      <= '1';
HostIF.v-253-          //  write_done <= '1';
--
Huffman.v-100-
Huffman.v:101:// @todo: fix, doesn't convert
Huffman.v-102-    parameter [1:0]
Huffman.v-103-      IDLE    = 0,
Huffman.v-104-      RUN_VLC = 1,
Huffman.v-105-      RUN_VLI = 2,
Huffman.v-106-      PAD     = 3;
--
Huffman.v-179-    //-----------------------------------------------------------------
Huffman.v:180:    // @todo: fix, manually instantiate, converter 
Huffman.v-181-    //U_DC_ROM : entity work.DC_ROM
Huffman.v-182-    //port map
Huffman.v-183-    //(
Huffman.v-184-    //      CLK                => CLK,
Huffman.v-185-    //      RST                => RST,
--
Huffman.v-194-    //-----------------------------------------------------------------
Huffman.v:195:    // @todo: fix, manually instantiate, converter   
Huffman.v-196-    //U_AC_ROM : entity work.AC_ROM
Huffman.v-197-    //port map
Huffman.v-198-    //(
Huffman.v-199-    //      CLK                => CLK,
Huffman.v-200-    //      RST                => RST,
--
Huffman.v-210-    //-----------------------------------------------------------------
Huffman.v:211:    // @todo: fix, manually instantiate, converter   
Huffman.v-212-    //U_DC_CR_ROM : entity work.DC_CR_ROM
Huffman.v-213-    //port map
Huffman.v-214-    //(
Huffman.v-215-    //      CLK                => CLK,
Huffman.v-216-    //      RST                => RST,
--
Huffman.v-225-    //-----------------------------------------------------------------
Huffman.v:226:    // @todo: fix, manually instantiate, converter   
Huffman.v-227-    //U_AC_CR_ROM : entity work.AC_CR_ROM
Huffman.v-228-    //port map
Huffman.v-229-    //(
Huffman.v-230-    //      CLK                => CLK,
Huffman.v-231-    //      RST                => RST,
--
Huffman.v-241-    //-----------------------------------------------------------------
Huffman.v:242:    // @todo: fix, manually instantiate, converter   
Huffman.v-243-    //U_DoubleFifo : entity work.DoubleFifo
Huffman.v-244-    //port map
Huffman.v-245-    //(
Huffman.v-246-    //      CLK                => CLK,
Huffman.v-247-    //      RST                => RST,
--
Huffman.v-260-    //-----------------------------------------------------------------
Huffman.v:261:    // @todo: fix, manually instantiate, converter
Huffman.v-262-    
Huffman.v-263-    always @(posedge CLK or posedge RST) begin
Huffman.v-264-	if(RST == 1'b 1) begin
Huffman.v-265-	    rle_buf_sel_s <= 1'b 0;
Huffman.v-266-	end 
--
Huffman.v-473-		      // shift word reg left to skip bytes already written to FIFO
Huffman.v:474:		      // @todo: fix no convert
Huffman.v-475-		      //word_reg <= shift_left(word_reg, to_integer(num_fifo_wrs & "000"));
Huffman.v-476-		      // adjust bit pointer after some bytes were written to FIFO
Huffman.v-477-		      // modulo 8 operation
Huffman.v-478-		      bit_ptr <= bit_ptr - {num_fifo_wrs,3'b 000};
Huffman.v-479-		      HFW_running <= 1'b 0;
--
Huffman.v-498-		      // shift word reg left to skip bytes already written to FIFO
Huffman.v:499:		      // @todo: fix, didn't convert
Huffman.v-500-		      //word_reg <= shift_left(word_reg, to_integer(num_fifo_wrs & "000"));
Huffman.v-501-		      // adjust bit pointer after some bytes were written to FIFO
Huffman.v-502-		      // modulo 8 operation
Huffman.v-503-		      bit_ptr <= bit_ptr - {num_fifo_wrs,3'b 000};
Huffman.v-504-		      HFW_running <= 1'b0;
--
Huffman.v-507-			  // end of segment
Huffman.v:508:			  // @todo: fix, doesn't convert
Huffman.v-509-			  //if bit_ptr - (num_fifo_wrs & "000") /= 0 and last_block = '1' then
Huffman.v-510-			  //  state <= PAD;  
Huffman.v-511-			  //else
Huffman.v-512-			  //  ready_pb <= '1';
Huffman.v-513-			  //  state    <= IDLE;
--
JFIFGen.v-89-#(
JFIFGen.v:90:  /// @todo: these were constnats from JPEG_PKG, not sure if
JFIFGen.v-91-  ///    this should be repeated in each module or in a header
JFIFGen.v-92-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
JFIFGen.v-93-  parameter C_HDR_SIZE = 623
JFIFGen.v-94-)  
JFIFGen.v-95-(
--
JpegEnc.v-343-	 .ready_pb           (fdct_ready	   ),
JpegEnc.v:344:	 // @todo: fix "settings"
JpegEnc.v-345-	 //.fdct_sm_settings   (fdct_sm_settings	   ),
JpegEnc.v-346-  	 
JpegEnc.v-347-	 //-- BUF_FIFO	      			   
JpegEnc.v-348-	 .bf_fifo_rd         (fdct_fifo_rd	   ),
JpegEnc.v-349-	 .bf_fifo_q          (fdct_fifo_q  	   ),
--
JpegEnc.v-375-	 .ready_pb           (zig_ready	    ),
JpegEnc.v:376:	 	 // @todo: fix "settings"
JpegEnc.v-377-	 //.zig_sm_settings    (zig_sm_settings  ),
JpegEnc.v-378-  	 
JpegEnc.v-379-	 //-- Quantizer      			    
JpegEnc.v-380-	 .qua_buf_sel        (qua_buf_sel   ),
JpegEnc.v-381-	 .qua_rdaddr         (qua_rdaddr    ),
--
JpegEnc.v-402-	 .ready_pb           (qua_ready	   ),
JpegEnc.v:403:	 // @todo: fix "settings"		   
JpegEnc.v-404-	 //.qua_sm_settings    (qua_sm_settings	   ),
JpegEnc.v-405-  	
JpegEnc.v-406-	 //-- RLE	      			   ),
JpegEnc.v-407-	 .rle_buf_sel        (rle_buf_sel	   ),
JpegEnc.v-408-	 .rle_rdaddr         (rle_rdaddr	   ),
--
JpegEnc.v-435-	 .ready_pb           (rle_ready 	),
JpegEnc.v:436:	 // @todo: fix "settings"
JpegEnc.v-437-	 //.rle_sm_settings    (rle_sm_settings,	  ),
JpegEnc.v-438-  	 
JpegEnc.v-439-	 //-- HUFFMAN	      			  
JpegEnc.v-440-	 .huf_buf_sel        (huf_buf_sel       ),
JpegEnc.v-441-	 .huf_rden           (huf_rden 	        ),
--
JpegEnc.v-456-    
JpegEnc.v:457:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-458-  //U_RLE_TOP : entity work.RLE_TOP
JpegEnc.v-459-  //port map
JpegEnc.v-460-  //(
JpegEnc.v-461-  //      CLK                => CLK,
JpegEnc.v-462-  //      RST                => RST,
--
JpegEnc.v-488-  //-----------------------------------------------------------------
JpegEnc.v:489:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-490-  //U_Huffman : entity work.Huffman
JpegEnc.v-491-  //port map
JpegEnc.v-492-  //(
JpegEnc.v-493-  //      CLK                => CLK,
JpegEnc.v-494-  //      RST                => RST,
--
JpegEnc.v-523-  //-----------------------------------------------------------------
JpegEnc.v:524:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-525-  //U_ByteStuffer : entity work.ByteStuffer
JpegEnc.v-526-  //port map
JpegEnc.v-527-  //(
JpegEnc.v-528-  //      CLK                => CLK,
JpegEnc.v-529-  //      RST                => RST,
--
JpegEnc.v-555-  //-----------------------------------------------------------------
JpegEnc.v:556:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-557-  //U_JFIFGen : entity work.JFIFGen
JpegEnc.v-558-  //port map
JpegEnc.v-559-  //(
JpegEnc.v-560-  //      CLK                => CLK,
JpegEnc.v-561-  //      RST                => RST,
--
JpegEnc.v-586-  //-----------------------------------------------------------------
JpegEnc.v:587:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-588-  //U_OutMux : entity work.OutMux
JpegEnc.v-589-  //port map
JpegEnc.v-590-  //(
JpegEnc.v-591-  //      CLK                => CLK,
JpegEnc.v-592-  //      RST                => RST,
--
MDCT.v-107-
MDCT.v:108:    // @todo: fix, converter doesn't handle user defined types
MDCT.v-109-    
MDCT.v-110-    //signal romedatao_s          : T_ROM1DATAO;
MDCT.v-111-    //signal romodatao_s          : T_ROM1DATAO;
MDCT.v-112-    //signal romeaddro_s          : T_ROM1ADDRO;
MDCT.v-113-    //signal romoaddro_s          : T_ROM1ADDRO;
--
MDCT.v-137-  //----------------------------
MDCT.v:138:  // @todo: fix, manually instantiate
MDCT.v-139-  //U_DCT1D : entity work.DCT1D
MDCT.v-140-  //  port map(       
MDCT.v-141-  //      clk          => clk,         
MDCT.v-142-  //      rst          => rst,      
MDCT.v-143-  //      dcti         => dcti,   
--
MDCT.v-159-  //----------------------------
MDCT.v:160:  // @todo: fix, manually instantiate  
MDCT.v-161-  //U_DCT2D : entity work.DCT2D
MDCT.v-162-  //  port map(       
MDCT.v-163-  //      clk          => clk,         
MDCT.v-164-  //      rst          => rst,      
MDCT.v-165-  //      romedatao    => rome2datao_s,
--
MDCT.v-180-  //----------------------------
MDCT.v:181:  // @todo: fix, manually instantiate
MDCT.v-182-  //U1_RAM : entity work.RAM   
MDCT.v-183-  //  port map (      
MDCT.v-184-  //        d          => ramdatai_s,               
MDCT.v-185-  //        waddr      => ramwaddro_s,     
MDCT.v-186-  //        raddr      => ramraddro_s,     
--
MDCT.v-194-  //----------------------------
MDCT.v:195:  // @todo: fix, manually instantiate
MDCT.v-196-  //U2_RAM : entity work.RAM   
MDCT.v-197-  //  port map (      
MDCT.v-198-  //        d          => ramdatai_s,               
MDCT.v-199-  //        waddr      => ramwaddro_s,     
MDCT.v-200-  //        raddr      => ramraddro_s,     
--
MDCT.v-212-  //----------------------------
MDCT.v:213:  // @todo: fix, manually instantiate
MDCT.v-214-  //U_DBUFCTL : entity work.DBUFCTL         
MDCT.v-215-  //        port map(         
MDCT.v-216-  //                clk            => clk,
MDCT.v-217-  //                rst            => rst,
MDCT.v-218-  //    wmemsel        => wmemsel_s,
--
MDCT.v-228-  //----------------------------
MDCT.v:229:  // @todo: fix, manually instantiate
MDCT.v-230-  //G_ROM_ST1 : for i in 0 to 8 generate
MDCT.v-231-  //  U1_ROME : entity work.ROME 
MDCT.v-232-  //  port map( 
MDCT.v-233-  //       addr        => romeaddro_s(i), 
MDCT.v-234-  //       clk         => clk,   
--
MDCT.v-249-  //----------------------------
MDCT.v:250:  // @todo: fix, manually instantiate
MDCT.v-251-  //G_ROM_ST2 : for i in 0 to 10 generate
MDCT.v-252-  //  U2_ROME : entity work.ROME 
MDCT.v-253-  //  port map( 
MDCT.v-254-  //       addr        => rome2addro_s(i), 
MDCT.v-255-  //       clk         => clk,   
--
QUANTIZER.v-108-  //--------------------------
QUANTIZER.v:109:  // @todo manually instantiate
QUANTIZER.v-110-  //U_RAMQ : entity work.RAMZ
QUANTIZER.v-111-  //  generic map
QUANTIZER.v-112-  //  (
QUANTIZER.v-113-  //    RAMADDR_W    => RAMQADDR_W,
QUANTIZER.v-114-  //    RAMDATA_W    => RAMQDATA_W
--
QUANTIZER.v-127-  assign divisor_s[SIZE_C - 1:RAMQDATA_W] = {(((SIZE_C - 1))-((RAMQDATA_W))+1){1'b0}};
QUANTIZER.v:128:  // @todo manually instantiate
QUANTIZER.v-129-  //r_divider : entity work.r_divider
QUANTIZER.v-130-  //port map
QUANTIZER.v-131-  //(
QUANTIZER.v-132-  //     rst   => rst,
QUANTIZER.v-133-  //     clk   => clk,
--
QUANTIZER.v-171-      if(divalid == 1'b 1) begin
QUANTIZER.v:172:        // @todo fix
QUANTIZER.v-173-        //romaddr_s <= romaddr_s + TO_UNSIGNED(1,romaddr_s'length);
QUANTIZER.v-174-      end
QUANTIZER.v-175-      //pipeline_reg <= pipeline_reg(pipeline_reg'length-2 downto 0) & divalid;
QUANTIZER.v-176-      pipeline_reg <= {pipeline_reg[5 - 2:0],divalid};
QUANTIZER.v-177-      di_d1 <= di;
QUANTIZER.v:178:      // @todo fix the following
QUANTIZER.v-179-      // sign_bit_pipe <= sign_bit_pipe(sign_bit_pipe'length-2 downto 0) & di(SIZE_C-1);
QUANTIZER.v-180-    end
QUANTIZER.v-181-  end
QUANTIZER.v-182-
QUANTIZER.v:183:  // @todo: fix
QUANTIZER.v-184-  assign dovalid = pipeline_reg[4];
QUANTIZER.v-185-//------------------------------------------------------------------------------
QUANTIZER.v-186-
QUANTIZER.v-187-endmodule
--
QUANT_TOP.v-143-  //-----------------------------------------------------------------
QUANT_TOP.v:144:  // @todo: instantiate manually
QUANT_TOP.v-145-  //U_quantizer : entity work.quantizer
QUANT_TOP.v-146-  //generic map
QUANT_TOP.v-147-  //  ( 
QUANT_TOP.v-148-  //    SIZE_C        => 12,
QUANT_TOP.v-149-  //    RAMQADDR_W    => 7,
--
QUANT_TOP.v-168-  //-----------------------------------------------------------------
QUANT_TOP.v:169:  // @todo: manually instantiate
QUANT_TOP.v-170-  //U_RAMZ : entity work.RAMZ
QUANT_TOP.v-171-  //generic map
QUANT_TOP.v-172-  //( 
QUANT_TOP.v-173-  //    RAMADDR_W     => 7,
QUANT_TOP.v-174-  //    RAMDATA_W     => 12
--
RLE_TOP.v-141-  //-----------------------------------------------------------------
RLE_TOP.v:142:  // @todo: manual instantiation
RLE_TOP.v-143-  //U_rle : entity work.rle
RLE_TOP.v-144-  //generic map
RLE_TOP.v-145-  //  ( 
RLE_TOP.v-146-  //    RAMADDR_W  => 6,
RLE_TOP.v-147-  //    RAMDATA_W  => 12
--
RLE_TOP.v-169-  //-----------------------------------------------------------------
RLE_TOP.v:170:  // @todo: manual instantiation
RLE_TOP.v-171-  //U_RleDoubleFifo : entity work.RleDoubleFifo
RLE_TOP.v-172-  //port map
RLE_TOP.v-173-  //(
RLE_TOP.v-174-  //      CLK                => CLK,
RLE_TOP.v-175-  //      RST                => RST,
--
RLE_TOP.v-209-        // EOB can only be on AC!
RLE_TOP.v:210:        // @todo: manually fix!
RLE_TOP.v-211-        //if dbuf_data = (dbuf_data'range => '0') and wr_cnt /= 0 then
RLE_TOP.v-212-        //  ready_pb <= '1';
RLE_TOP.v-213-        //else
RLE_TOP.v-214-        //  if wr_cnt + resize(unsigned(rle_runlength), wr_cnt'length) = 64-1 then
RLE_TOP.v-215-        //    ready_pb <= '1';
--
RLE_TOP.v-217-        //end if;
RLE_TOP.v:218:        // end @todo manually fix
RLE_TOP.v-219-      end
RLE_TOP.v-220-    end
RLE_TOP.v-221-  end
RLE_TOP.v-222-
RLE_TOP.v-223-  //-----------------------------------------------------------------
--
RLE.v-179-          3'b000, 3'b001 : begin
RLE.v:180:            // @todo: fix
RLE.v-181-            //acc_reg <= RESIZE(SIGNED(di),RAMDATA_W+1) - RESIZE(prev_dc_reg_0,RAMDATA_W+1);
RLE.v-182-	     acc_reg <= $signed(di) - prev_dc_reg_0;	     
RLE.v-183-             prev_dc_reg_0 <= (di);
RLE.v-184-          end
RLE.v-185-          3'b010 : begin
RLE.v:186:            // @todo: fix              
RLE.v-187-            //acc_reg <= RESIZE(SIGNED(di),RAMDATA_W+1) - RESIZE(prev_dc_reg_1,RAMDATA_W+1);
RLE.v-188-	     acc_reg <= $signed(di) - prev_dc_reg_1;
RLE.v-189-             prev_dc_reg_1 <= (di);
RLE.v-190-          end
RLE.v-191-          3'b011 : begin
RLE.v:192:            // @todo: fix              
RLE.v-193-            //acc_reg <= RESIZE(SIGNED(di),RAMDATA_W+1) - RESIZE(prev_dc_reg_2,RAMDATA_W+1);
RLE.v-194-	     acc_reg <= $signed(di) - prev_dc_reg_2;	     
RLE.v-195-             prev_dc_reg_2 <= (di);
RLE.v-196-          end
RLE.v-197-            default : begin
--
RLE.v-221-            if(zero_cnt <= 15) begin
RLE.v:222:              // @todo: fix              
RLE.v-223-              //acc_reg        <= RESIZE(SIGNED(di),RAMDATA_W+1);              
RLE.v-224-              runlength_reg <= zero_cnt[3:0];
RLE.v-225-              zero_cnt <= {6{1'b0}};
RLE.v-226-              dovalid_reg <= 1'b1;
RLE.v-227-              // zero_cnt > 15
--
RLE.v-246-        if(zero_cnt <= 15) begin
RLE.v:247:          // @todo: fix          
RLE.v-248-          //acc_reg        <= RESIZE(SIGNED(zrl_di),RAMDATA_W+1);
RLE.v-249-          runlength_reg <= zero_cnt[3:0];
RLE.v-250-          if(((zrl_di)) == 0) begin
RLE.v-251-            //zero_cnt     <= to_unsigned(1,zero_cnt'length);
RLE.v-252-            zero_cnt <= (1);
--
RLE.v-304-       
RLE.v:305:      // @todo: need to manually fix (doh)
RLE.v-306-      // compute Symbol-1 Size
RLE.v-307-      //if acc_reg = TO_SIGNED(-1,RAMDATA_W+1) then
RLE.v-308-      //  size_reg <= TO_UNSIGNED(1,SIZE_REG_C);
RLE.v-309-      //elsif (acc_reg < TO_SIGNED(-1,RAMDATA_W+1) and acc_reg > TO_SIGNED(-4,RAMDATA_W+1)) then
RLE.v-310-      //  size_reg <= TO_UNSIGNED(2,SIZE_REG_C);
--
RLE.v-364-       
RLE.v:365:      // @todo: fix, need to manually fix
RLE.v-366-      // compute Symbol-1 Size
RLE.v-367-      // positive input
RLE.v-368-      //if acc_reg = TO_SIGNED(1,RAMDATA_W+1) then
RLE.v-369-      //  size_reg <= TO_UNSIGNED(1,SIZE_REG_C);
RLE.v-370-      //elsif (acc_reg > TO_SIGNED(1,RAMDATA_W+1) and acc_reg < TO_SIGNED(4,RAMDATA_W+1)) then
--
ZIGZAG.v-92-       
ZIGZAG.v:93:   // @todo: need to manually convert the ZIGZIG RAM'r
ZIGZAG.v-94-   //type ZIGZAG_TYPE is   array (0 to 2**RAMADDR_W-1) of INTEGER range 0 to 2**RAMADDR_W-1;
ZIGZAG.v-95-   //constant ZIGZAG_ARRAY : ZIGZAG_TYPE := 
ZIGZAG.v-96-   //                    (
ZIGZAG.v-97-   //                     0,1,8,16,9,2,3,10, 
ZIGZAG.v-98-   //                     17,24,32,25,18,11,4,5,
--
ZIGZAG.v-113-
ZIGZAG.v:114:      // @todo: ...
ZIGZAG.v-115-   end
ZIGZAG.v-116-   
ZIGZAG.v-117-   wire 		    fifo_wr;
ZIGZAG.v-118-   wire [11:0] 		    fifo_q;
ZIGZAG.v-119-   wire 		    fifo_full;
--
ZZ_TOP.v-107-   output ready_pb;
ZZ_TOP.v:108:   // @todo: can't use record, break it down to the 3 members.
ZZ_TOP.v-109-   //    port is currently unused.
ZZ_TOP.v-110-   //zig_sm_settings    : in  T_SM_SETTINGS;
ZZ_TOP.v-111-   // Quantizer
ZZ_TOP.v-112-   input  qua_buf_sel;
ZZ_TOP.v-113-   input [5:0] qua_rdaddr;
