BUF_FIFO.v:    /// @todo: better home, these were in a global package in
BUF_FIFO.v-    ///    the VHDL version.  Might need to use a header file,
BUF_FIFO.v-    ///    don't believe the 
BUF_FIFO.v-    parameter C_EXTRA_LINES = 8;
BUF_FIFO.v-    parameter C_MAX_LINE_WIDTH = 1280;
BUF_FIFO.v-    
BUF_FIFO.v-    // HOST PROG
BUF_FIFO.v-    // HOST DATA
--
ByteStuffer.v:  /// @todo: these were constants from JPEG_PKG, not sure if
ByteStuffer.v-  ///    this should be repeated in each module or in a header
ByteStuffer.v-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
ByteStuffer.v-  parameter C_HDR_SIZE = 623
ByteStuffer.v-)  
ByteStuffer.v-(
ByteStuffer.v- input wire 	   CLK,
ByteStuffer.v- input wire 	   RST,
--
CtrlSM.v:    // @todo: check, VHDL used global values from the package
CtrlSM.v-    //    need to verify these are correct
CtrlSM.v-    localparam NUM_STAGES = 6;
CtrlSM.v-    localparam CMP_MAX = 4;
CtrlSM.v-	
CtrlSM.v:    /// @todo: verify correct encoding for states
CtrlSM.v-    localparam
CtrlSM.v-      IDLES = 1,
CtrlSM.v-      JFIF  = 2,
CtrlSM.v-      HORIZ = 3,
CtrlSM.v-      COMP  = 4,
CtrlSM.v-      VERT  = 5,
CtrlSM.v-      EOI   = 6;
--
DCT1D.v:  /// @todo: these were constants from MDCT_PKG, not sure if
DCT1D.v-  ///    this should be repeated in each module or in a header
DCT1D.v-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
DCT1D.v-  parameter IP_W        = 8,  
DCT1D.v-  parameter OP_W        = 12,
DCT1D.v-  parameter N           = 8,
DCT1D.v-  parameter COE_W       = 12,
DCT1D.v-  parameter ROMDATA_W   = COE_W+2,
--
DCT2D.v:  /// @todo: these were constnats from MDCT_PKG, not sure if
DCT2D.v-  ///    this should be repeated in each module or in a header
DCT2D.v-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
DCT2D.v-  parameter IP_W        = 8,  
DCT2D.v-  parameter OP_W        = 12,
DCT2D.v-  parameter N           = 8,
DCT2D.v-  parameter COE_W       = 12,
DCT2D.v-  parameter ROMDATA_W   = COE_W+2,
--
DCT2D.v:	    /// @todo see if these need to be cast to signed ($signed)
DCT2D.v-	    ///    both DCT1D and DCT2D
DCT2D.v-	    
DCT2D.v-	    if (1'b0 == even_not_odd) begin
DCT2D.v-		dcto_1 <= romedatao[0] + (romedatao[1] << 1) + (romedatao[2] << 2);
DCT2D.v-	    end
DCT2D.v-	    else begin
DCT2D.v-		dcto_1 <= romodatao[0] + (romodatao[1] << 1) + (romodatao[2] << 2);
--
DoubleFifo.v:  // @todo: manually instantiate
DoubleFifo.v-  //U_FIFO_1 : entity work.FIFO   
DoubleFifo.v-  //generic map
DoubleFifo.v-  //(
DoubleFifo.v-  //      DATA_WIDTH        => 8,
DoubleFifo.v-  //      ADDR_WIDTH        => 7
DoubleFifo.v-  //)
DoubleFifo.v-  //port map 
--
DoubleFifo.v:  // @todo: manually instantiate
DoubleFifo.v-  //U_FIFO_2 : entity work.FIFO   
DoubleFifo.v-  //generic map
DoubleFifo.v-  //(
DoubleFifo.v-  //      DATA_WIDTH        => 8,
DoubleFifo.v-  //      ADDR_WIDTH        => 7
DoubleFifo.v-  //)
DoubleFifo.v-  //port map 
--
FDCT.v:    // @todo: fix, manaully fix record usage
FDCT.v-    //fdct_sm_settings   : in  T_SM_SETTINGS;
FDCT.v-    // BUF_FIFO
FDCT.v-    // ZIG ZAG
FDCT.v-    // HOST
FDCT.v-    
FDCT.v-    
FDCT.v-    
FDCT.v:    // @todo: fix, manually convert ??
FDCT.v-    //constant C_Y_1       : signed(14 downto 0) := to_signed(4899,  15);
FDCT.v-    //constant C_Y_2       : signed(14 downto 0) := to_signed(9617,  15);
FDCT.v-    //constant C_Y_3       : signed(14 downto 0) := to_signed(1868,  15);
FDCT.v-    //constant C_Cb_1      : signed(14 downto 0) := to_signed(-2764, 15);
FDCT.v-    //constant C_Cb_2      : signed(14 downto 0) := to_signed(-5428, 15);
FDCT.v-    //constant C_Cb_3      : signed(14 downto 0) := to_signed(8192,  15);
FDCT.v-    //constant C_Cr_1      : signed(14 downto 0) := to_signed(8192,  15);
--
FDCT.v:  // @todo: fix, manually convert (instantiate)
FDCT.v-  //U_FRAM1 : entity work.RAMZ
FDCT.v-  //generic map
FDCT.v-  //( 
FDCT.v-  //    RAMADDR_W     => 7,
FDCT.v-  //    RAMDATA_W     => 24
FDCT.v-  //)
FDCT.v-  //port map
--
FDCT.v:			      /// @todo verify this is correct
FDCT.v-			      fram1_raddr <= {1'b0, fram1_line_cnt_p1, 3'b000};
FDCT.v-			  end
FDCT.v-		      end
FDCT.v-		      else begin
FDCT.v-			  fram1_raddr <= (((fram1_raddr)) + 2);
FDCT.v-		      end
FDCT.v-		  end
--
FDCT.v:  // @todo: fix, manually convert (instantiate)
FDCT.v-  //U_MDCT : entity work.MDCT
FDCT.v-  //      port map
FDCT.v-  //(	  
FDCT.v-  //      	clk          => CLK,
FDCT.v-  //      	rst          => RST,
FDCT.v-  //  dcti         => mdct_data_in,
FDCT.v-  //  idv          => mdct_idval,
--
FDCT.v:  // @todo: fix, manually convert (instantiate)
FDCT.v-  //U_FIFO1 : entity work.FIFO   
FDCT.v-  //generic map
FDCT.v-  //(
FDCT.v-  //      DATA_WIDTH        => 12,
FDCT.v-  //      ADDR_WIDTH        => 9
FDCT.v-  //)
FDCT.v-  //port map 
--
FDCT.v:      // @todo: fix, manually convert
FDCT.v-      //Cb_Reg <= Cb_Reg_1 + Cb_Reg_2 + Cb_Reg_3 + to_signed(128*16384, Cb_Reg'length);
FDCT.v-      //Cr_Reg <= Cr_Reg_1 + Cr_Reg_2 + Cr_Reg_3 + to_signed(128*16384, Cr_Reg'length);
FDCT.v-    end
FDCT.v-  end
FDCT.v-
FDCT.v-  assign Y_8bit = (Y_Reg[21:14]);
FDCT.v-  assign Cb_8bit = (Cb_Reg[21:14]);
--
FDCT.v:  // @todo: fix, manually convert (instantiate)  
FDCT.v-  //U_RAMZ : entity work.RAMZ
FDCT.v-  //generic map
FDCT.v-  //( 
FDCT.v-  //    RAMADDR_W     => 7,
FDCT.v-  //    RAMDATA_W     => 12
FDCT.v-  //)
FDCT.v-  //port map
--
FIFO.v:      // @todo: manual convert the following 
FIFO.v-      //if count_reg = 2**ADDR_WIDTH or
FIFO.v-      //  (count_reg = 2**ADDR_WIDTH-1 and wr_en_reg = '1' and rd_en_reg = '0') then 
FIFO.v-      //  full_reg        <= '1';
FIFO.v-      //else
FIFO.v-      //  full_reg        <= '0';
FIFO.v-      //end if;  
FIFO.v-    end
--
HostIF.v:    // @todo: verify these constants, some converted funky?
HostIF.v-    parameter C_ENC_START_REG        = 36'h 0000_0000;
HostIF.v-    parameter C_IMAGE_SIZE_REG       = 36'h 0000_0004;
HostIF.v-    parameter C_IMAGE_RAM_ACCESS_REG = 36'h 0000_0008;
HostIF.v-    parameter C_ENC_STS_REG          = 36'h 0000_000C;
HostIF.v-    parameter C_COD_DATA_ADDR_REG    = 36'h 0000_0010;
HostIF.v-    parameter C_ENC_LENGTH_REG       = 36'h 0000_0014;
HostIF.v-    parameter C_QUANTIZER_RAM_LUM    = {28'h 0000_01, 8'b0};
--
HostIF.v:          // @todo: fix, manually convert
HostIF.v-          //if std_match(OPB_ABus, C_QUANTIZER_RAM_LUM) then
HostIF.v-          //  qdata      <= OPB_DBus_in(qdata'range);
HostIF.v-          //  qaddr      <= '0' & OPB_ABus(qaddr'high+2-1 downto 2);
HostIF.v-          //  qwren      <= '1';
HostIF.v-          //  write_done <= '1';
HostIF.v-          //end if;
HostIF.v-          //
--
Huffman.v:// @todo: fix, doesn't convert
Huffman.v-    parameter [1:0]
Huffman.v-      IDLE    = 0,
Huffman.v-      RUN_VLC = 1,
Huffman.v-      RUN_VLI = 2,
Huffman.v-      PAD     = 3;
Huffman.v-
Huffman.v-    parameter C_M = 23;
--
Huffman.v:    // @todo: fix, manually instantiate, converter 
Huffman.v-    //U_DC_ROM : entity work.DC_ROM
Huffman.v-    //port map
Huffman.v-    //(
Huffman.v-    //      CLK                => CLK,
Huffman.v-    //      RST                => RST,
Huffman.v-    //      VLI_size           => VLI_size,
Huffman.v-    //                         
--
Huffman.v:    // @todo: fix, manually instantiate, converter   
Huffman.v-    //U_AC_ROM : entity work.AC_ROM
Huffman.v-    //port map
Huffman.v-    //(
Huffman.v-    //      CLK                => CLK,
Huffman.v-    //      RST                => RST,
Huffman.v-    //      runlength          => runlength,
Huffman.v-    //      VLI_size           => VLI_size,
--
Huffman.v:    // @todo: fix, manually instantiate, converter   
Huffman.v-    //U_DC_CR_ROM : entity work.DC_CR_ROM
Huffman.v-    //port map
Huffman.v-    //(
Huffman.v-    //      CLK                => CLK,
Huffman.v-    //      RST                => RST,
Huffman.v-    //      VLI_size           => VLI_size,
Huffman.v-    //                         
--
Huffman.v:    // @todo: fix, manually instantiate, converter   
Huffman.v-    //U_AC_CR_ROM : entity work.AC_CR_ROM
Huffman.v-    //port map
Huffman.v-    //(
Huffman.v-    //      CLK                => CLK,
Huffman.v-    //      RST                => RST,
Huffman.v-    //      runlength          => runlength,
Huffman.v-    //      VLI_size           => VLI_size,
--
Huffman.v:    // @todo: fix, manually instantiate, converter   
Huffman.v-    //U_DoubleFifo : entity work.DoubleFifo
Huffman.v-    //port map
Huffman.v-    //(
Huffman.v-    //      CLK                => CLK,
Huffman.v-    //      RST                => RST,
Huffman.v-    //      -- HUFFMAN
Huffman.v-    //      data_in            => fifo_wbyte,
--
Huffman.v:    // @todo: fix, manually instantiate, converter
Huffman.v-    
Huffman.v-    always @(posedge CLK or posedge RST) begin
Huffman.v-	if(RST == 1'b 1) begin
Huffman.v-	    rle_buf_sel_s <= 1'b 0;
Huffman.v-	end 
Huffman.v-	else begin
Huffman.v-	    if(start_pb == 1'b 1) begin
--
Huffman.v:		      // @todo: fix no convert
Huffman.v-		      //word_reg <= shift_left(word_reg, to_integer(num_fifo_wrs & "000"));
Huffman.v-		      // adjust bit pointer after some bytes were written to FIFO
Huffman.v-		      // modulo 8 operation
Huffman.v-		      bit_ptr <= bit_ptr - {num_fifo_wrs,3'b 000};
Huffman.v-		      HFW_running <= 1'b 0;
Huffman.v-		      first_rle_word <= 1'b 0;
Huffman.v-		      state <= RUN_VLI;
--
Huffman.v:		      // @todo: fix, didn't convert
Huffman.v-		      //word_reg <= shift_left(word_reg, to_integer(num_fifo_wrs & "000"));
Huffman.v-		      // adjust bit pointer after some bytes were written to FIFO
Huffman.v-		      // modulo 8 operation
Huffman.v-		      bit_ptr <= bit_ptr - {num_fifo_wrs,3'b 000};
Huffman.v-		      HFW_running <= 1'b0;
Huffman.v-		      // end of block
Huffman.v-		      if(rle_fifo_empty == 1'b1) begin
--
Huffman.v:			  // @todo: fix, doesn't convert
Huffman.v-			  //if bit_ptr - (num_fifo_wrs & "000") /= 0 and last_block = '1' then
Huffman.v-			  //  state <= PAD;  
Huffman.v-			  //else
Huffman.v-			  //  ready_pb <= '1';
Huffman.v-			  //  state    <= IDLE;
Huffman.v-			  //end if;
Huffman.v-		      end
--
JFIFGen.v:  /// @todo: these were constnats from JPEG_PKG, not sure if
JFIFGen.v-  ///    this should be repeated in each module or in a header
JFIFGen.v-  ///    (ugh preprocessor) not sure if iverilog supports SV pkg.
JFIFGen.v-  parameter C_HDR_SIZE = 623
JFIFGen.v-)  
JFIFGen.v-(
JFIFGen.v- input wire 	   CLK,
JFIFGen.v- input wire 	   RST,
--
JpegEnc.v:	 // @todo: fix "settings"
JpegEnc.v-	 //.fdct_sm_settings   (fdct_sm_settings	   ),
JpegEnc.v-  	 
JpegEnc.v-	 //-- BUF_FIFO	      			   
JpegEnc.v-	 .bf_fifo_rd         (fdct_fifo_rd	   ),
JpegEnc.v-	 .bf_fifo_q          (fdct_fifo_q  	   ),
JpegEnc.v-	 .bf_fifo_hf_full    (fdct_fifo_hf_full   ),
JpegEnc.v-  	 
--
JpegEnc.v:	 	 // @todo: fix "settings"
JpegEnc.v-	 //.zig_sm_settings    (zig_sm_settings  ),
JpegEnc.v-  	 
JpegEnc.v-	 //-- Quantizer      			    
JpegEnc.v-	 .qua_buf_sel        (qua_buf_sel   ),
JpegEnc.v-	 .qua_rdaddr         (qua_rdaddr    ),
JpegEnc.v-	 .qua_data           (qua_data	    ),
JpegEnc.v-  	 
--
JpegEnc.v:	 // @todo: fix "settings"		   
JpegEnc.v-	 //.qua_sm_settings    (qua_sm_settings	   ),
JpegEnc.v-  	
JpegEnc.v-	 //-- RLE	      			   ),
JpegEnc.v-	 .rle_buf_sel        (rle_buf_sel	   ),
JpegEnc.v-	 .rle_rdaddr         (rle_rdaddr	   ),
JpegEnc.v-	 .rle_data           (rle_data		   ),
JpegEnc.v-	 
--
JpegEnc.v:	 // @todo: fix "settings"
JpegEnc.v-	 //.rle_sm_settings    (rle_sm_settings,	  ),
JpegEnc.v-  	 
JpegEnc.v-	 //-- HUFFMAN	      			  
JpegEnc.v-	 .huf_buf_sel        (huf_buf_sel       ),
JpegEnc.v-	 .huf_rden           (huf_rden 	        ),
JpegEnc.v-	 .huf_runlength      (huf_runlength     ),
JpegEnc.v-	 .huf_size           (huf_size 	        ),
--
JpegEnc.v:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-  //U_RLE_TOP : entity work.RLE_TOP
JpegEnc.v-  //port map
JpegEnc.v-  //(
JpegEnc.v-  //      CLK                => CLK,
JpegEnc.v-  //      RST                => RST,
JpegEnc.v-  //      -- CTRL
JpegEnc.v-  //      start_pb           => rle_start,
--
JpegEnc.v:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-  //U_Huffman : entity work.Huffman
JpegEnc.v-  //port map
JpegEnc.v-  //(
JpegEnc.v-  //      CLK                => CLK,
JpegEnc.v-  //      RST                => RST,
JpegEnc.v-  //      -- CTRL
JpegEnc.v-  //      start_pb           => huf_start,
--
JpegEnc.v:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-  //U_ByteStuffer : entity work.ByteStuffer
JpegEnc.v-  //port map
JpegEnc.v-  //(
JpegEnc.v-  //      CLK                => CLK,
JpegEnc.v-  //      RST                => RST,
JpegEnc.v-  //      -- CTRL
JpegEnc.v-  //      start_pb           => bs_start,
--
JpegEnc.v:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-  //U_JFIFGen : entity work.JFIFGen
JpegEnc.v-  //port map
JpegEnc.v-  //(
JpegEnc.v-  //      CLK                => CLK,
JpegEnc.v-  //      RST                => RST,
JpegEnc.v-  //      -- CTRL
JpegEnc.v-  //      start              => jfif_start,
--
JpegEnc.v:  // @todo: fix, manually instantiate, converter doesn't handle  
JpegEnc.v-  //U_OutMux : entity work.OutMux
JpegEnc.v-  //port map
JpegEnc.v-  //(
JpegEnc.v-  //      CLK                => CLK,
JpegEnc.v-  //      RST                => RST,
JpegEnc.v-  //      -- CTRL
JpegEnc.v-  //      out_mux_ctrl       => out_mux_ctrl,
--
MDCT.v:    // @todo: fix, converter doesn't handle user defined types
MDCT.v-    
MDCT.v-    //signal romedatao_s          : T_ROM1DATAO;
MDCT.v-    //signal romodatao_s          : T_ROM1DATAO;
MDCT.v-    //signal romeaddro_s          : T_ROM1ADDRO;
MDCT.v-    //signal romoaddro_s          : T_ROM1ADDRO;
MDCT.v-    //
MDCT.v-    //signal rome2datao_s         : T_ROM2DATAO;
--
MDCT.v:  // @todo: fix, manually instantiate
MDCT.v-  //U_DCT1D : entity work.DCT1D
MDCT.v-  //  port map(       
MDCT.v-  //      clk          => clk,         
MDCT.v-  //      rst          => rst,      
MDCT.v-  //      dcti         => dcti,   
MDCT.v-  //      idv          => idv,
MDCT.v-  //      romedatao    => romedatao_s,
--
MDCT.v:  // @todo: fix, manually instantiate  
MDCT.v-  //U_DCT2D : entity work.DCT2D
MDCT.v-  //  port map(       
MDCT.v-  //      clk          => clk,         
MDCT.v-  //      rst          => rst,      
MDCT.v-  //      romedatao    => rome2datao_s,
MDCT.v-  //      romodatao    => romo2datao_s,
MDCT.v-  //      ramdatao     => ramdatao_s,
--
MDCT.v:  // @todo: fix, manually instantiate
MDCT.v-  //U1_RAM : entity work.RAM   
MDCT.v-  //  port map (      
MDCT.v-  //        d          => ramdatai_s,               
MDCT.v-  //        waddr      => ramwaddro_s,     
MDCT.v-  //        raddr      => ramraddro_s,     
MDCT.v-  //        we         => ramwe1_s,     
MDCT.v-  //        clk        => clk,      
--
MDCT.v:  // @todo: fix, manually instantiate
MDCT.v-  //U2_RAM : entity work.RAM   
MDCT.v-  //  port map (      
MDCT.v-  //        d          => ramdatai_s,               
MDCT.v-  //        waddr      => ramwaddro_s,     
MDCT.v-  //        raddr      => ramraddro_s,     
MDCT.v-  //        we         => ramwe2_s,     
MDCT.v-  //        clk        => clk,      
--
MDCT.v:  // @todo: fix, manually instantiate
MDCT.v-  //U_DBUFCTL : entity work.DBUFCTL         
MDCT.v-  //        port map(         
MDCT.v-  //                clk            => clk,
MDCT.v-  //                rst            => rst,
MDCT.v-  //    wmemsel        => wmemsel_s,
MDCT.v-  //    rmemsel        => rmemsel_s,
MDCT.v-  //    datareadyack   => datareadyack_s,
--
MDCT.v:  // @todo: fix, manually instantiate
MDCT.v-  //G_ROM_ST1 : for i in 0 to 8 generate
MDCT.v-  //  U1_ROME : entity work.ROME 
MDCT.v-  //  port map( 
MDCT.v-  //       addr        => romeaddro_s(i), 
MDCT.v-  //       clk         => clk,   
MDCT.v-  //       
MDCT.v-  //       datao       => romedatao_s(i)
--
MDCT.v:  // @todo: fix, manually instantiate
MDCT.v-  //G_ROM_ST2 : for i in 0 to 10 generate
MDCT.v-  //  U2_ROME : entity work.ROME 
MDCT.v-  //  port map( 
MDCT.v-  //       addr        => rome2addro_s(i), 
MDCT.v-  //       clk         => clk,   
MDCT.v-  //       
MDCT.v-  //       datao       => rome2datao_s(i)
--
QUANTIZER.v:  // @todo manually instantiate
QUANTIZER.v-  //U_RAMQ : entity work.RAMZ
QUANTIZER.v-  //  generic map
QUANTIZER.v-  //  (
QUANTIZER.v-  //    RAMADDR_W    => RAMQADDR_W,
QUANTIZER.v-  //    RAMDATA_W    => RAMQDATA_W
QUANTIZER.v-  //  )
QUANTIZER.v-  //  port map
--
QUANTIZER.v:  // @todo manually instantiate
QUANTIZER.v-  //r_divider : entity work.r_divider
QUANTIZER.v-  //port map
QUANTIZER.v-  //(
QUANTIZER.v-  //     rst   => rst,
QUANTIZER.v-  //     clk   => clk,
QUANTIZER.v-  //     a     => di_d1,     
QUANTIZER.v-  //     d     => romdatao_s,    
--
QUANTIZER.v:        // @todo fix
QUANTIZER.v-        //romaddr_s <= romaddr_s + TO_UNSIGNED(1,romaddr_s'length);
QUANTIZER.v-      end
QUANTIZER.v-      //pipeline_reg <= pipeline_reg(pipeline_reg'length-2 downto 0) & divalid;
QUANTIZER.v-      pipeline_reg <= {pipeline_reg[5 - 2:0],divalid};
QUANTIZER.v-      di_d1 <= di;
QUANTIZER.v:      // @todo fix the following
QUANTIZER.v-      // sign_bit_pipe <= sign_bit_pipe(sign_bit_pipe'length-2 downto 0) & di(SIZE_C-1);
QUANTIZER.v-    end
QUANTIZER.v-  end
QUANTIZER.v-
QUANTIZER.v:  // @todo: fix
QUANTIZER.v-  assign dovalid = pipeline_reg[4];
QUANTIZER.v-//------------------------------------------------------------------------------
QUANTIZER.v-
QUANTIZER.v-endmodule
--
QUANT_TOP.v:  // @todo: instantiate manually
QUANT_TOP.v-  //U_quantizer : entity work.quantizer
QUANT_TOP.v-  //generic map
QUANT_TOP.v-  //  ( 
QUANT_TOP.v-  //    SIZE_C        => 12,
QUANT_TOP.v-  //    RAMQADDR_W    => 7,
QUANT_TOP.v-  //    RAMQDATA_W    => 8
QUANT_TOP.v-  //  )
--
QUANT_TOP.v:  // @todo: manually instantiate
QUANT_TOP.v-  //U_RAMZ : entity work.RAMZ
QUANT_TOP.v-  //generic map
QUANT_TOP.v-  //( 
QUANT_TOP.v-  //    RAMADDR_W     => 7,
QUANT_TOP.v-  //    RAMDATA_W     => 12
QUANT_TOP.v-  //)
QUANT_TOP.v-  //port map
--
RLE_TOP.v:  // @todo: manual instantiation
RLE_TOP.v-  //U_rle : entity work.rle
RLE_TOP.v-  //generic map
RLE_TOP.v-  //  ( 
RLE_TOP.v-  //    RAMADDR_W  => 6,
RLE_TOP.v-  //    RAMDATA_W  => 12
RLE_TOP.v-  //  )
RLE_TOP.v-  //port map
--
RLE_TOP.v:  // @todo: manual instantiation
RLE_TOP.v-  //U_RleDoubleFifo : entity work.RleDoubleFifo
RLE_TOP.v-  //port map
RLE_TOP.v-  //(
RLE_TOP.v-  //      CLK                => CLK,
RLE_TOP.v-  //      RST                => RST,
RLE_TOP.v-  //      -- RLE
RLE_TOP.v-  //      data_in            => dbuf_data,
--
RLE_TOP.v:        // @todo: manually fix!
RLE_TOP.v-        //if dbuf_data = (dbuf_data'range => '0') and wr_cnt /= 0 then
RLE_TOP.v-        //  ready_pb <= '1';
RLE_TOP.v-        //else
RLE_TOP.v-        //  if wr_cnt + resize(unsigned(rle_runlength), wr_cnt'length) = 64-1 then
RLE_TOP.v-        //    ready_pb <= '1';
RLE_TOP.v-        //  end if;
RLE_TOP.v-        //end if;
RLE_TOP.v:        // end @todo manually fix
RLE_TOP.v-      end
RLE_TOP.v-    end
RLE_TOP.v-  end
RLE_TOP.v-
RLE_TOP.v-  //-----------------------------------------------------------------
RLE_TOP.v-  // fdct_buf_sel
RLE_TOP.v-  //-----------------------------------------------------------------
--
RLE.v:            // @todo: fix
RLE.v-            //acc_reg <= RESIZE(SIGNED(di),RAMDATA_W+1) - RESIZE(prev_dc_reg_0,RAMDATA_W+1);
RLE.v-	     acc_reg <= $signed(di) - prev_dc_reg_0;	     
RLE.v-             prev_dc_reg_0 <= (di);
RLE.v-          end
RLE.v-          3'b010 : begin
RLE.v:            // @todo: fix              
RLE.v-            //acc_reg <= RESIZE(SIGNED(di),RAMDATA_W+1) - RESIZE(prev_dc_reg_1,RAMDATA_W+1);
RLE.v-	     acc_reg <= $signed(di) - prev_dc_reg_1;
RLE.v-             prev_dc_reg_1 <= (di);
RLE.v-          end
RLE.v-          3'b011 : begin
RLE.v:            // @todo: fix              
RLE.v-            //acc_reg <= RESIZE(SIGNED(di),RAMDATA_W+1) - RESIZE(prev_dc_reg_2,RAMDATA_W+1);
RLE.v-	     acc_reg <= $signed(di) - prev_dc_reg_2;	     
RLE.v-             prev_dc_reg_2 <= (di);
RLE.v-          end
RLE.v-            default : begin
RLE.v-            end
RLE.v-          endcase
--
RLE.v:              // @todo: fix              
RLE.v-              //acc_reg        <= RESIZE(SIGNED(di),RAMDATA_W+1);              
RLE.v-              runlength_reg <= zero_cnt[3:0];
RLE.v-              zero_cnt <= {6{1'b0}};
RLE.v-              dovalid_reg <= 1'b1;
RLE.v-              // zero_cnt > 15
RLE.v-            end
RLE.v-            else begin
--
RLE.v:          // @todo: fix          
RLE.v-          //acc_reg        <= RESIZE(SIGNED(zrl_di),RAMDATA_W+1);
RLE.v-          runlength_reg <= zero_cnt[3:0];
RLE.v-          if(((zrl_di)) == 0) begin
RLE.v-            //zero_cnt     <= to_unsigned(1,zero_cnt'length);
RLE.v-            zero_cnt <= (1);
RLE.v-          end
RLE.v-          else begin
--
RLE.v:      // @todo: need to manually fix (doh)
RLE.v-      // compute Symbol-1 Size
RLE.v-      //if acc_reg = TO_SIGNED(-1,RAMDATA_W+1) then
RLE.v-      //  size_reg <= TO_UNSIGNED(1,SIZE_REG_C);
RLE.v-      //elsif (acc_reg < TO_SIGNED(-1,RAMDATA_W+1) and acc_reg > TO_SIGNED(-4,RAMDATA_W+1)) then
RLE.v-      //  size_reg <= TO_UNSIGNED(2,SIZE_REG_C);
RLE.v-      //elsif (acc_reg < TO_SIGNED(-3,RAMDATA_W+1) and acc_reg > TO_SIGNED(-8,RAMDATA_W+1)) then
RLE.v-      //  size_reg <= TO_UNSIGNED(3,SIZE_REG_C);
--
RLE.v:      // @todo: fix, need to manually fix
RLE.v-      // compute Symbol-1 Size
RLE.v-      // positive input
RLE.v-      //if acc_reg = TO_SIGNED(1,RAMDATA_W+1) then
RLE.v-      //  size_reg <= TO_UNSIGNED(1,SIZE_REG_C);
RLE.v-      //elsif (acc_reg > TO_SIGNED(1,RAMDATA_W+1) and acc_reg < TO_SIGNED(4,RAMDATA_W+1)) then
RLE.v-      //  size_reg <= TO_UNSIGNED(2,SIZE_REG_C);
RLE.v-      //elsif (acc_reg > TO_SIGNED(3,RAMDATA_W+1) and acc_reg < TO_SIGNED(8,RAMDATA_W+1)) then
--
ZIGZAG.v:   // @todo: need to manually convert the ZIGZIG RAM'r
ZIGZAG.v-   //type ZIGZAG_TYPE is   array (0 to 2**RAMADDR_W-1) of INTEGER range 0 to 2**RAMADDR_W-1;
ZIGZAG.v-   //constant ZIGZAG_ARRAY : ZIGZAG_TYPE := 
ZIGZAG.v-   //                    (
ZIGZAG.v-   //                     0,1,8,16,9,2,3,10, 
ZIGZAG.v-   //                     17,24,32,25,18,11,4,5,
ZIGZAG.v-   //                     12,19,26,33,40,48,41,34,
ZIGZAG.v-   //                     27,20,13,6,7,14,21,28,
--
ZIGZAG.v:      // @todo: ...
ZIGZAG.v-   end
ZIGZAG.v-   
ZIGZAG.v-   wire 		    fifo_wr;
ZIGZAG.v-   wire [11:0] 		    fifo_q;
ZIGZAG.v-   wire 		    fifo_full;
ZIGZAG.v-   wire [6:0] 		    fifo_count;
ZIGZAG.v-   wire [11:0] 		    fifo_data_in;
--
ZZ_TOP.v:   // @todo: can't use record, break it down to the 3 members.
ZZ_TOP.v-   //    port is currently unused.
ZZ_TOP.v-   //zig_sm_settings    : in  T_SM_SETTINGS;
ZZ_TOP.v-   // Quantizer
ZZ_TOP.v-   input  qua_buf_sel;
ZZ_TOP.v-   input [5:0] qua_rdaddr;
ZZ_TOP.v-   output [11:0] qua_data;
ZZ_TOP.v-   // FDCT
